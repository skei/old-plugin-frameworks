#ifndef kode_linux_timer_included
#define kode_linux_timer_included
//----------------------------------------------------------------------

// http://man7.org/linux/man-pages/man2/timer_create.2.html
// -lrt

//----------------------------------------------------------------------

#include <time.h>     // timer
#include <signal.h>   // sigval
#include <errno.h>    // errno

#include "base/kode_math.h"

//----------------------------------------------------------------------
//
//----------------------------------------------------------------------

class KODE_TimerListener {
  public:
    virtual void on_timerCallback(void) {}
};

//----------

void kode_timer_callback(sigval val) {
  KODE_TimerListener* listener = (KODE_TimerListener*)val.sival_ptr;
  if (listener) listener->on_timerCallback();
}

//----------------------------------------------------------------------
//
//----------------------------------------------------------------------

class KODE_Timer {

private:

  sigevent    MSigEvent;
  timer_t     MTimer;
  itimerspec  MTimerSpec;

public:

  KODE_Timer(KODE_TimerListener* AListener) {
    MSigEvent.sigev_notify            = SIGEV_THREAD;
    MSigEvent.sigev_notify_function   = kode_timer_callback;
    MSigEvent.sigev_notify_attributes = KODE_NULL;
    MSigEvent.sigev_value.sival_int   = 0; // timer index?
    MSigEvent.sigev_value.sival_ptr   = AListener;
    //int res =
    timer_create(CLOCK_REALTIME, &MSigEvent, &MTimer);
    //KODE_Trace("MTimer %i\n",MTimer);
    /*if (res == -1) {
      switch(errno) {
        case EAGAIN:
          KODE_Trace("timer_create error: Temporary error during kernel allocation of timer structures.\n");
          break;
        case EINVAL:
          KODE_Trace("timer_create error: Clock ID, sigev_notify, sigev_signo, or sigev_notify_thread_id is invalid.\n");
          break;
        case ENOMEM:
          KODE_Trace("timer_create error: Could not allocate memory.\n");
          break;
      }
    }*/
  }

  //----------

  // timer_delete() deletes the timer whose ID is given in timerid.  If
  // the timer was armed at the time of this call, it is disarmed before
  // being deleted.  The treatment of any pending signal generated by the
  // deleted timer is unspecified.

  ~KODE_Timer() {
    timer_delete(MTimer);
  }

  //----------

  void start(float ms, bool oneshot=false) {
    float s = ms * 0.001f;
    float sec = KODE_Trunc(s);
    float nsec = (s-sec) * 1000000000; // 1000000.0f * (sec - KODE_Fract(s));
    time_t isec = sec;
    long insec = nsec;
    //KODE_Trace("s %.4f sec %.4f nsec %.4f isec %i insec %i\n",s,sec,nsec,isec,insec);
    if (oneshot) {
      MTimerSpec.it_interval.tv_sec   = 0;
      MTimerSpec.it_interval.tv_nsec  = 0;
    }
    else {
      MTimerSpec.it_interval.tv_sec   = isec;
      MTimerSpec.it_interval.tv_nsec  = insec;
    }
    MTimerSpec.it_value.tv_sec      = isec;
    MTimerSpec.it_value.tv_nsec     = insec;
    //int res =
    timer_settime(MTimer, 0, &MTimerSpec, 0);
    /*if (res == -1) {
      switch(errno) {
        case EFAULT:
          KODE_Trace("timer_settime error: new_value, old_value, or curr_value is not a valid pointer.\n");
          break;
        //case EINVAL:
        //  KODE_Trace("timer_settime error: timerid is invalid.\n");
        //  break;
        case EINVAL:
          KODE_Trace("timer_settime: new_value.it_value is negative; or new_value.it_value.tv_nsec is negative or greater than 999,999,999.\n");
          break;
      }
    }*/
  }

  //----------

  // If new_value->it_value specifies a nonzero value (i.e., either sub‐
  // field is nonzero), then timer_settime() arms (starts) the timer, set‐
  // ting it to initially expire at the given time.  (If the timer was
  // already armed, then the previous settings are overwritten.)  If
  // new_value->it_value specifies a zero value (i.e., both subfields are
  // zero), then the timer is disarmed.

  void stop(void) {
    MTimerSpec.it_interval.tv_sec   = 0;
    MTimerSpec.it_interval.tv_nsec  = 0;
    MTimerSpec.it_value.tv_sec      = 0;
    MTimerSpec.it_value.tv_nsec     = 0;
    timer_settime(&MTimer, 0, &MTimerSpec, 0);
  }

};


//----------------------------------------------------------------------
#endif